<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RubyGPT Chat</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; background: #202123; color: #ececf1; }
  #app { max-width: 720px; margin: 20px auto; }
  select, input, button { font-size: 1rem; padding: 0.5rem; }
  .chat-window { border: 1px solid #444; padding: 1rem; height: 500px; overflow-y: auto; background: #343541; }
  .message { margin-bottom: 1rem; }
  .user { color: #9aedfe; }
  .bot { color: #e6e6e6; }
</style>
</head>
<body>
  <div id="app">
    <h1>RubyGPT Chat</h1>
    <label for="model">Choose AI Model:</label>
    <select id="model">
      <option value="chatgpt">ChatGPT (OpenAI)</option>
      <option value="rubyai-beta">RubyAI Beta (Custom AI)</option>
      <option value="gemini">Gemini (Coming Soon)</option>
      <option value="grok">Grok (Coming Soon)</option>
    </select>
    <div class="chat-window" id="chatWindow"></div>
    <form id="chatForm">
      <input id="chatInput" autocomplete="off" placeholder="Type your message..." style="width: 80%;" />
      <button type="submit">Send</button>
    </form>
  </div>

  <script>
    // Your API keys here (private repo or GitHub Pages private!)
    const OPENAI_API_KEY = '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';
    const SERPAPI_API_KEY = '4c4668697fd3a2ca1da7462e99391a9b76bf200b77b86983d4230b0dd56f232e';

    const chatForm = document.getElementById('chatForm');
    const chatInput = document.getElementById('chatInput');
    const chatWindow = document.getElementById('chatWindow');
    const modelSelect = document.getElementById('model');

    function appendMessage(sender, text) {
      const div = document.createElement('div');
      div.classList.add('message');
      div.classList.add(sender === 'user' ? 'user' : 'bot');
      div.textContent = (sender === 'user' ? 'You: ' : 'RubyGPT: ') + text;
      chatWindow.appendChild(div);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    async function callOpenAI(message) {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: "gpt-4",
          messages: [{ role: "user", content: message }],
          temperature: 0.7
        }),
      });
      const data = await response.json();
      if (data.choices && data.choices.length > 0) {
        return data.choices[0].message.content.trim();
      }
      throw new Error('OpenAI response error');
    }

    async function callSerpAPI(query) {
      const response = await fetch(`https://serpapi.com/search.json?q=${encodeURIComponent(query)}&api_key=${SERPAPI_API_KEY}`);
      const data = await response.json();
      if (data.organic_results && data.organic_results.length > 0) {
        return data.organic_results[0].snippet || 'No good results found.';
      }
      return 'No results found.';
    }

    async function callRubyAIBeta(message) {
      // Placeholder for your custom RubyAI beta model logic.
      // For demo, just echo message reversed after delay
      await new Promise(r => setTimeout(r, 1000));
      return message.split('').reverse().join('');
    }

    async function handleUserMessage(message, model) {
      if (model === 'chatgpt') {
        // If question looks like needing Google search, use SerpAPI first
        const searchTriggers = ['safe', 'how', 'what', 'when', 'where', 'who', 'why', '?'];
        if (searchTriggers.some(trigger => message.toLowerCase().includes(trigger))) {
          try {
            const serpAnswer = await callSerpAPI(message);
            return `According to Google search: ${serpAnswer}`;
          } catch {
            // fallback to OpenAI if SerpAPI fails
            return await callOpenAI(message);
          }
        } else {
          return await callOpenAI(message);
        }
      } else if (model === 'rubyai-beta') {
        return await callRubyAIBeta(message);
      } else if (model === 'gemini' || model === 'grok') {
        return `The ${model} model is coming soon!`;
      } else {
        return 'Unknown model selected.';
      }
    }

    chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const message = chatInput.value.trim();
      if (!message) return;

      appendMessage('user', message);
      chatInput.value = '';
      chatInput.disabled = true;

      const model = modelSelect.value;
      try {
        const reply = await handleUserMessage(message, model);
        appendMessage('bot', reply);
      } catch (err) {
        appendMessage('bot', 'Error getting response: ' + err.message);
      } finally {
        chatInput.disabled = false;
        chatInput.focus();
      }
    });

    chatInput.focus();
  </script>
</body>
</html>
